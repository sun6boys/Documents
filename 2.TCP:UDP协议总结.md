        
滑动窗口  http://blog.csdn.net/wdscq1234/article/details/52444277

https://www.cnblogs.com/woaiyy/p/3554182.html


---------
目前大多数app和服务器通信的时候才有的HTTP应用层协议，而HTTP又是TCP协议实现的，所以TCP协议的重要性不言而喻。TCP是一个传输层协议位于IP协议网络层之上。从很多书籍和资料上解释TCP是可靠的传输层协议。结合下面的内容就会得到分析为什么TCP协议是可靠的传输层协议。

### 1.TCP Header
一个TCP包由header和payload组成，payload就是待传输的数据，header信息中包含了一些对payload的描述以及一些TCP传输控制策略等，如下图。

![icon](http://p.blog.csdn.net/images/p_blog_csdn_net/lpnueg4/EntryImages/20091120/TCP+bit%E5%89%AF%E6%9C%AC.png)


- **Source Port** `源端口号`标识发送主机发起传送的应用程序。端口号在IP总结一文中作了解释，所以当时为什么说端口号应属于传输层当中的内容。
- **Destonation Port** `目标端口号` 标识目标主机接收数据的应用程序。
- **Sequence Number** `序列号` 标识该TCP包中payload第一个字节的编号，发送方必填。
- **Acknowledgment Number** `确认号` 接收方每次接收到发送方传来的数据包需要告诉发送方我已经收到了该数据（TCP可靠性体现之一，当然也并不是每个包都会被回复，下文会具体叙述），`确认号` = `序号和` + payload字节数 + 1,代表期待对方下次可以从序号号为**Acknowledgment Number**开始发送。意思是（Acknowledgment Number - 1）和它之前的数据已经成功收到，不需要重发那些。
- **Data Offset** 4位，也就是头部长度，指出TCP负载（数据）的开始位置。以4字节为单位，如"0101"表示20字节位置的数据为负载开始，也就是头部长度为20字节。
- **Control Falg** `控制标记`
 - **URG** 如果数值为1，表示这是一个携有紧急资料的封包
 - **ACK** 如果数值为1，表示该包需要回复，正常情况都是1
 - **PSH** 如果为1，通知接收方立即将数据包交给应用层，而不是等缓冲区满了再交付应用层
 - **SYN** 如果为1 表示双方进行同步沟通
 - **FIN** 如果未1 表示任意一方已经没有数据传输了，请求终止链接。

- **Window** `窗口` 接收窗口大小。用来进行流量控制，单位字节数。发送方有发送窗口，接收方有接收窗口，窗口大小代表着处理数据的能力，如果接收方发送数据的速度大于接收方处理数据的能力，那多余的数据将会丢失。
- **Checksum** `校验位`16位，对整个TCP报文段，即TCP头部和TCP数据进行校验和计算，并由目标端进行验证。当资料要传送出去的时候发送端会计算好封包资料大小然後得出这个检验值封包一起发送当接收端收到封包之後会再对资料大小进行计算看看是否和检验值一致如果结果不相称则被视为残缺封包会要求对方重发该个封包。
- ...

### 2. TCP分段
在[IP协议总结](https://github.com/sun6boys/Documents/blob/master/1.IP%E5%8D%8F%E8%AE%AE%E6%80%BB%E7%BB%93.md)中说到当数据包在经过网络层，如果数据包体积超过了MTU，会把数据包分片传输。IP包在复杂的网络传输当中，可能会发生各种意外情况，比如丢包等等。TCP既然被称为可靠的协议，显然要改变这个状况。

可靠性最大的体现在发送方给接收方的数据都能够接收到，如果某一个数据没有接收到，发送方需要重新给接收方再次发送。

所以TCP的header当中**Sequence Number**和**Acknowledgment Number**就是为了实现确认和重发功能，具体见上文。

**举例：**

- 发送方 需要发送1、2、3、4...、99、100共100个数字给接收方，TCP把这100个数字打包，在TCP header中记录**Sequence Number**，IP层接收到TCP层过来的数据，加上IP header超过了MTU大小，于是把数据包分片，第一片数据是1-50个数字，第二片是51 -100个数字，分别发送出去。

- 接收方收到第一个包，经过层层拆包，至TCP层，接收方根据**Sequence Number**回复一个**Acknowledgment Number**给接收方，接收方收到回复包，看到**Acknowledgment Number**会认为接收方已经收到完整数据了。

- 在这个过程当中发送方认为接收方已经收到了数据，而接收方可能只接收到了1-50的数据，51-100并没有接收到。

TCP为了避免这样的情况发生，他需要接管数据分段，避免被IP分片。

IP数据不会发生分片前提是： IP header + IP 实际传输的数据 <= MTU。

因为TCP也会封装header，他要保证单个数据包至IP层不会被分片，公式是：TCP header + TCP payload + IP header <= MTU.

暂且认为TCP header 和 IP header大小固定不变，在[IP协议总结](https://github.com/sun6boys/Documents/blob/master/1.IP%E5%8D%8F%E8%AE%AE%E6%80%BB%E7%BB%93.md)提到过MTU，MTU大小会因为数据传输过程中物理介质不一样，以及运营商流量计费采用了比如PPPoE等协议，会给数据包二次封装等原因造成了MTU的大小不一致。

既然如此，发送方和接收方就要在正式数据传输前，约定好TCP payload的最大体积以保证不会让IP分片，这就是**MSS**


由此可得出IP分片和TCP分段的区别：

- IP分片产生的原因是网络层的MTU；TCP分段产生原因是MSS，产生MSS原因其实也是MTU；
- IP分片由网络层完成，也在网络层进行重组；TCP分段是在传输层完成，并在传输层进行重组；

故采用TCP协议进行数据传输，是不会造成IP分片的。若数据过大，只会在传输层进行数据分段，到了IP层就不用分片。而我们常提到的IP分片是由于比如UDP传输协议造成的，因为UDP传输协议并未限定传输数据报的大小。

### 3.流量控制（Data Flow Control）
TCP的传输要保证数据能够准确到达目的地，如果不能，需要能检测出来并且重新发送数据。每一台设备都有自己的承载能力，如果发送方发送数据的速度超过了接收方处理数据的速度，那超过的那部分就会被丢弃，发送方一定时间内检测不到接收方回复的ACK，就会重新发送被丢弃的那些数据。为了提高效率，避免发送方发送速度太快，导致的重发，TCP引入了滑动窗口机制。

#### 3.1 滑动窗口

早前TCP为了保证可靠性采用的单次发生一个包，然后开启定时器，如果定时时间内收不到接收方ACK就重新发送刚才的包，等收到ACK后再发送下一个包，显然这样效率是很低的。 那如何一次可以发送多个包，并且不超过接收方处理数据的能力呢，滑动窗口可以解决类似问题。

所谓滑动窗口就是可变的窗口。

#### 3.1 发送窗口
发送窗口根据数据包状态划分大致划分四类

- **已回复** 已经收到接收方ACK的数据包
- **等待回复** 已经发送出去的数据包，但是没有收到ACK
- **尽快发送** 准备发送的数据包
- **未发送** 当TCP层收到应用层数据达到MSS值就会组装一个数据包，按序排列，这部分的数据包属于已组装但是超过接收方接收能力的数据包。

图一：

![icon](https://github.com/sun6boys/Documents/blob/master/Resources/fasongchuankou1.png?raw=true)

接收方和发送方建立连接后，接收方通过TCP header中window（字节）告知发送方我现在可以处理4个数据包，滑动窗口挪至1-4编号的位置，并将这4个包立即发送。

图二：
![icon](https://github.com/sun6boys/Documents/blob/master/Resources/fasongchuangkou3.png?raw=true)

接收方发送1-4数据包，如果等不到ACK需要重新发送，所以缓存下来，1-4号包状态变成等待回复。

图三：
![icon](https://github.com/sun6boys/Documents/blob/master/Resources/fasongchuangkou2.png?raw=true)

接收方给第1-2个包ACK了，并告知发送方，我现在还可以处理3个数据包，随机滑动窗口挪至3-7的区域。并将5-7的包发送出去。1-2号包会在发送缓存即将满时清除。


窗口以字节为单位，此处举例暂忽略，此处也忽略了TCP慢启动，会在第四章节介绍。


#### 3.2 接收窗口

#### 3.3 SACK 选择性确认

### 4.拥塞控制


------
由此可见MSS和ACK才是TCP称为可靠的主要原因，拥塞控制和流量控制只是为了保障它提高效率的。
 